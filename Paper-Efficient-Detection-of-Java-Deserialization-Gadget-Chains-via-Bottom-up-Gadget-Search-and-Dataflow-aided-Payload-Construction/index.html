<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="baidu-site-verification" content="5ZQsOe30cm" />
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"southsea.st","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqusjs","storage":true,"lazyload":false,"nav":null,"activeClass":"disqusjs"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="阅读笔记，2024 S&amp;P。 摘要 Java 反序列化中一个众所周知且严重的安全漏洞是 Java 对象注入（JOI），它使得远程攻击者能够注入一个精心制作的序列化对象，触发一系列内部 Java 方法（称为 gadgets），最终实现一系列严重的攻击后果，例如远程代码执行（RCE）和拒绝服务（DoS）攻击。">
<meta property="og:type" content="article">
<meta property="og:title" content="论文 Efficient Detection of Java Deserialization Gadget Chains via Bottom-up Gadget Search and Dataflow-aided Payload Construction">
<meta property="og:url" content="https://southsea.st/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/index.html">
<meta property="og:site_name" content="南溟NaN">
<meta property="og:description" content="阅读笔记，2024 S&amp;P。 摘要 Java 反序列化中一个众所周知且严重的安全漏洞是 Java 对象注入（JOI），它使得远程攻击者能够注入一个精心制作的序列化对象，触发一系列内部 Java 方法（称为 gadgets），最终实现一系列严重的攻击后果，例如远程代码执行（RCE）和拒绝服务（DoS）攻击。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-16T00:00:00.000Z">
<meta property="article:modified_time" content="2025-01-24T03:34:53.072Z">
<meta property="article:author" content="南溟NaN">
<meta property="article:tag" content="Paper">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://southsea.st/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://southsea.st/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/","path":"Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/","title":"论文 Efficient Detection of Java Deserialization Gadget Chains via Bottom-up Gadget Search and Dataflow-aided Payload Construction"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>论文 Efficient Detection of Java Deserialization Gadget Chains via Bottom-up Gadget Search and Dataflow-aided Payload Construction | 南溟NaN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">南溟NaN</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">在这浩瀚星河的你是什么</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">24</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">68</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A0%94%E7%A9%B6%E5%86%85%E5%AE%B9"><span class="nav-number">2.</span> <span class="nav-text">研究内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%91%E6%88%98-i%E9%9D%99%E6%80%81%E8%B7%AF%E5%BE%84%E7%88%86%E7%82%B8"><span class="nav-number">3.1.</span> <span class="nav-text">挑战 I：静态路径爆炸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%91%E6%88%98ii%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B5%8C%E5%A5%97%E7%9A%84%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">挑战II：并行和嵌套的注入对象结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">系统架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stage-i"><span class="nav-number">4.1.1.</span> <span class="nav-text">Stage I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stage-ii"><span class="nav-number">4.1.2.</span> <span class="nav-text">Stage II</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1%E8%AF%86%E5%88%AB%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">步骤 1：识别反序列化入口点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90%E8%AF%86%E5%88%AB-gadget-%E7%89%87%E6%AE%B5"><span class="nav-number">4.3.</span> <span class="nav-text">步骤
2：使用静态污染分析识别 gadget 片段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gadget-%E7%89%87%E6%AE%B5%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.1.</span> <span class="nav-text">Gadget 片段定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gadget-%E7%89%87%E6%AE%B5%E7%9A%84%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">Gadget
片段的动态方法调用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E8%B0%83%E7%94%A8"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">多态调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">反射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3%E4%BD%BF%E7%94%A8%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95%E9%93%BE%E6%8E%A5-fragment-%E7%89%87%E6%AE%B5%E4%BB%A5%E6%9E%84%E5%BB%BA-gadget-%E9%93%BE"><span class="nav-number">4.4.</span> <span class="nav-text">步骤
3：使用自下而上的方法链接 Fragment 片段以构建 Gadget 链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">4.4.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%90%86-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">定理 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%90%86-2"><span class="nav-number">4.4.3.</span> <span class="nav-text">定理 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-4%E6%A0%B9%E6%8D%AE%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%BA%A6%E6%9D%9F%E5%BB%BA%E7%AB%8B-iocd"><span class="nav-number">4.5.</span> <span class="nav-text">步骤
4：根据注入对象相关约束建立 IOCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#object-%E5%92%8C-field-%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB"><span class="nav-number">4.5.1.</span> <span class="nav-text">Object 和 Field
实例之间的层次关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-field-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="nav-number">4.5.2.</span> <span class="nav-text">与 Field 相关的条件分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#field-%E4%BE%9D%E8%B5%96%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.5.3.</span> <span class="nav-text">Field 依赖约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%9B%BE"><span class="nav-number">4.5.4.</span> <span class="nav-text">注入对象构造图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-5iocd-%E5%A2%9E%E5%BC%BA%E6%96%B9%E5%90%91%E6%80%A7%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="nav-number">4.6.</span> <span class="nav-text">步骤 5：IOCD
增强方向性模糊测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-iocd-%E7%9A%84%E7%A7%8D%E5%AD%90%E7%94%9F%E6%88%90"><span class="nav-number">4.6.1.</span> <span class="nav-text">基于 IOCD 的种子生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%84%9F%E7%9F%A5%E7%A7%8D%E5%AD%90%E5%8F%98%E5%8A%A8"><span class="nav-number">4.6.2.</span> <span class="nav-text">依赖感知种子变动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9D%A1%E4%BB%B6%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8F%98%E5%8A%A8"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">基于条件约束的变动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8F%98%E5%8A%A8"><span class="nav-number">4.6.2.2.</span> <span class="nav-text">基于对象结构约束的变动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-field-%E4%BE%9D%E8%B5%96%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%8F%98%E5%8A%A8"><span class="nav-number">4.6.2.3.</span> <span class="nav-text">基于 Field 依赖约束的变动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97-field-%E5%80%BC%E9%87%8D%E7%94%A8"><span class="nav-number">4.6.2.3.1.</span> <span class="nav-text">嵌套 Field 值重用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BA%E5%AE%9A%E8%B0%83%E6%95%B4"><span class="nav-number">4.6.2.3.2.</span> <span class="nav-text">顺序固定调整</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="南溟NaN"
      src="https://avatars.githubusercontent.com/u/34373144?v=4">
  <p class="site-author-name" itemprop="name">南溟NaN</p>
  <div class="site-description" itemprop="description">在这浩瀚星河的你是什么</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/southseast" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;southseast" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:st.southsea@gmail.com" title="E-Mail → mailto:st.southsea@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://southsea.st/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/34373144?v=4">
      <meta itemprop="name" content="南溟NaN">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南溟NaN">
      <meta itemprop="description" content="在这浩瀚星河的你是什么">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="论文 Efficient Detection of Java Deserialization Gadget Chains via Bottom-up Gadget Search and Dataflow-aided Payload Construction | 南溟NaN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          论文 Efficient Detection of Java Deserialization Gadget Chains via Bottom-up Gadget Search and Dataflow-aided Payload Construction
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-16T00:00:00+00:00">2024-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>阅读笔记，<strong>2024 S&amp;P</strong>。</p>
<h1 id="摘要">摘要</h1>
<p><strong>Java</strong> 反序列化中一个众所周知且严重的安全漏洞是
<strong>Java</strong>
对象注入（<strong>JOI</strong>），它使得远程攻击者能够注入一个精心制作的序列化对象，触发一系列内部
<strong>Java</strong> 方法（称为
<strong>gadgets</strong>），最终实现一系列严重的攻击后果，例如远程代码执行（<strong>RCE</strong>）和拒绝服务（<strong>DoS</strong>）攻击。</p>
<span id="more"></span>
<h1 id="研究内容">研究内容</h1>
<p>本文设计并实现了一种新颖的 <strong>Java</strong> 反序列化
<strong>gadget</strong> 检测框架，称为 <strong>JDD</strong>。</p>
<ol type="1">
<li><p>通过自下而上的方法解决了静态路径爆炸问题：首先寻找
<strong>gadget</strong> 片段，然后从接收器到源链 <strong>gadget</strong>
片段。该方法将最大静态搜索时间从指数级降低到多项式级，即从 <span
class="math inline">\(O(eM^n)\)</span> 到 <span
class="math inline">\(O(M^2n^3 + enM)\)</span>，其中 <span
class="math inline">\(n\)</span> 是 <strong>gadget</strong>
链中动态函数调用的数量，<span class="math inline">\(M\)</span>
是动态函数调用候选的平均数量，<span class="math inline">\(e\)</span>​
是入口点的数量。</p>
<p>更重要的是，<strong>JDD</strong> 能够重用在先前漏洞中发现的现有
<strong>gadget</strong> 片段，进一步加快了搜索过程。</p></li>
<li><p>构建了所谓的注入对象构建图（<strong>Injection Object Construction
Diagram</strong>），该图模拟了注入对象 <strong>Field</strong>
之间的数据流依赖关系，以促进动态 <strong>fuzzing</strong>，丰富
<strong>payload</strong> 中的细粒度对象关系。</p>
<blockquote>
<p>这个 <strong>Injection Object Construction Diagram</strong>
在后面的系统设计中有提到。</p>
</blockquote></li>
</ol>
<h1 id="概述">概述</h1>
<p><strong>JOI</strong> 漏洞的利用需要以下两个条件：</p>
<ol type="1">
<li>一个执行路径，可以在反序列化过程中调用可以执行恶意代码（或上传任意文件、拒绝服务等）的安全敏感方法，称为
<strong>gadget</strong> 链。</li>
<li>一个驱动 <strong>gadget</strong>
链执行的序列化对象，称为注入对象。</li>
</ol>
<p>因此，<strong>JDD</strong> 有两个主要的检测目标：</p>
<ol type="1">
<li>使用静态分析找到潜在的 <strong>gadget</strong> 链。</li>
<li>动态生成可利用的注入对象以验证 <strong>gadget</strong>
链的可利用性。</li>
</ol>
<p>以下是 <strong>JDD</strong> 在 <strong>sofa-rpc</strong> 中发现的一个
<strong>0day gadget</strong> 链。</p>
<blockquote>
<p>第 <strong>4</strong> 行开始执行了一个 <strong>put()</strong>
方法，然后不停调用。</p>
<p>一直到第 <strong>54</strong> 行执行了 <strong>invoke()</strong>
方法完成反序列化。</p>
</blockquote>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240217150052682.png"
alt="Figure 1: A Motivating Example of a Zero-day Gadget Chain with Five Fragments (Note that code is simplified for easy understanding.)" />
<figcaption aria-hidden="true">Figure 1: A Motivating Example of a
Zero-day Gadget Chain with Five Fragments (Note that code is simplified
for easy understanding.)</figcaption>
</figure>
<p>以下是攻击者的利用链。</p>
<blockquote>
<p>第 <strong>15–18</strong> 行创建了两个相同 <strong>hashCode</strong>
的 <strong>NodeImpl</strong>，为了触发 <strong>equals()</strong>
方法【<strong>gadget</strong> 中的第 <strong>7</strong> 行】。</p>
<p>第 <strong>12/13/19</strong> 行创建了
<strong>ConcurrentHashMap</strong> 并赋值，是为了调用
<strong>gadget</strong> 中的第 <strong>27</strong> 行。</p>
<p>第 <strong>2/20</strong> 行的赋值是为了调用 <strong>gadget</strong>
中的第 <strong>36</strong> 行。</p>
<p>最后 <strong>4-10</strong>
行是指定了远程加载动态代码的参数，攻击调用点在 <strong>gadget</strong>
中的第 <strong>54</strong> 行。</p>
</blockquote>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240217154742422.png"
alt="Figure 2: Exploit Code of Our Motivating Example in Figure 1 (An adversary serializes the returned object in Line 20 and sends it to the server)." />
<figcaption aria-hidden="true">Figure 2: Exploit Code of Our Motivating
Example in Figure 1 (An adversary serializes the returned object in Line
20 and sends it to the server).</figcaption>
</figure>
<h2 id="挑战-i静态路径爆炸">挑战 I：静态路径爆炸</h2>
<p>第一个挑战是对于以往自上而下的搜索来说，起始点和结束点之间所有可能路径的数量是指数级的，且有时候由于方法名相同会导致冗余，导致路径爆炸。</p>
<p>以图 <strong>1</strong> 为例：</p>
<ul>
<li><strong>Fragment I</strong> 和 <strong>II</strong> 之间的
<strong>equals()</strong> 方法的潜在候选数量可能为 <span
class="math inline">\(2,751\)</span>，对 <strong>II</strong> 和
<strong>III</strong> 之间的另一个 <strong>equals()</strong>
方法也适用。</li>
<li>然后，在 <strong>III</strong> 和 <strong>IV</strong> 之间的
<strong>get()</strong> 方法的候选数量为 <span
class="math inline">\(148\)</span>。</li>
<li>在 <strong>IV</strong> 和 <strong>V</strong> 之间的
<strong>createValue()</strong> 方法为 <span
class="math inline">\(12\)</span>。</li>
</ul>
<h3 id="解决方案">解决方案</h3>
<p>因此，如果使用深度优先搜索（<strong>DFS</strong>）来找到像
<strong>ODDFuzz</strong> 所做的 <strong>gadget</strong>
链，总执行路径数量可能为 <span class="math inline">\(2751×2751×148×12 =
13,440,769,776\)</span>，这几乎不可能。</p>
<p>对此 <strong>JDD</strong> 一次性分析所有可能的
<strong>gadget</strong>，形成片段，然后自下而上从结束点到起始点链接所有的片段，形成链。</p>
<p>具体来说，<strong>JDD</strong> 只需要分析 <span
class="math inline">\((12 + 2751 + 148) = 2,911\)</span>
个程序执行路径，并且在最多分析 $ (2911×2911 - 2751×2751 - 148×148 -
12×12)×2 + 2751 = 1,770,495$ 次片段链接，这仅仅是自上而下方法的 <span
class="math inline">\(0.01\%\)</span>。</p>
<h2
id="挑战ii并行和嵌套的注入对象结构">挑战II：并行和嵌套的注入对象结构</h2>
<p>第二个挑战是负载，即注入对象，可能具有复杂的结构，例如嵌套或并行对象。</p>
<p>下图显示了图 <strong>1</strong> 中示例的注入对象结构。</p>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240217170548258.png"
alt="Figure 3: Injection Object Structure of Motivation Example." />
<figcaption aria-hidden="true">Figure 3: Injection Object Structure of
Motivation Example.</figcaption>
</figure>
<p><strong>UIDfaults</strong> 和 <strong>ConcurrentHashMap</strong>
是正确 <strong>payload</strong> 中 <strong>NodeImpl</strong>
对象下的两个 <strong>key</strong>。</p>
<p>然而，先前的工作，如 <strong>ODDFuzz</strong>，仅考虑从
<strong>gadget</strong>
链推断出的类层次结构，因此它们将生成一个错误的对象结构，如
<strong>b</strong> 所示，因为在 <strong>ConcurrentHashMap</strong>
之后调用了 <strong>UIDfaults</strong> 的 <strong>get()</strong> 方法【图
<strong>1</strong> 中的第 <strong>27</strong> 行】。</p>
<h3 id="解决方案-1">解决方案</h3>
<p>本文使用了数据流辅助注入对象构建图（<strong>Injection Object
Construction Diagram</strong>）。</p>
<p>关键观察是不同的注入对象，例如它们的 Field ，通过数据流连接。</p>
<p>具体来说，图 <strong>1</strong>
中不同颜色的两条虚线显示了两个这样的数据流。</p>
<p><strong>key</strong>（第 <strong>8</strong> 行）流向
<strong>this.key</strong>（第 <strong>17</strong> 行），然后流向
<strong>this.table[index].key</strong>（第 <strong>27</strong>
行）。</p>
<p>然后，<strong>p.key</strong>（第 <strong>8</strong> 行）流向
<strong>((NodeImpl) obj).key</strong>（第 <strong>17</strong>
行），然后流向 <strong>(Map&lt;?,?&gt;)o</strong>（第
<strong>27</strong> 行）。</p>
<p>因此推断出有两个 <strong>NodeImpl</strong>
对象，<strong>UIDfaults</strong> 位于一个 <strong>NodeImpl</strong>
对象的键下，而不是 <strong>ConcurrentHashMap</strong> 的
<strong>table</strong> 下。</p>
<h1 id="设计">设计</h1>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240217172204035.png"
alt="Figure 4: The Overall Architecture of JDD with Two Stages." />
<figcaption aria-hidden="true">Figure 4: The Overall Architecture of JDD
with Two Stages.</figcaption>
</figure>
<h2 id="系统架构">系统架构</h2>
<h3 id="stage-i">Stage I</h3>
<p>从识别 <strong>sofa-rpc</strong>
中的入口点开始，然后将它们用作开始静态污染分析的起始点。</p>
<p>从每个入口点开始遍历目标程序的控制流和数据流图，直到动态方法调用，并将其视为一个片段。</p>
<p>然后，将动态方法的实现视为新的起始点，直到下一个动态方法调用，并将两者之间的代码视为新的片段。</p>
<p>在此过程中，<strong>JDD</strong> 识别包含结束点的一些
<strong>gadget</strong> 片段，如图 <strong>1 Fragment V</strong> 中的
<strong>MethodUtil.invoke()</strong>。</p>
<p>接下来，在步骤 <strong>3</strong> 中，使用该片段查找有动态调用
<strong>LazyValue.createValue()</strong> 方法的 <strong>Fragment
IV</strong>，以及根据先前的污染分析结果查找调用
<strong>createValue()</strong> 方法的对象的值。</p>
<p>随后，将 <strong>Fragment IV</strong> 作为新的起点来查找
<strong>Fragment III</strong>，并重复此过程，直到到达起始点，形成一个
<strong>gadget</strong> 链。</p>
<p>连接片段 <strong>Fragment IV</strong> 后，为了完成
<strong>gadget</strong> 链，<strong>JDD</strong>
将独立收集可能导致攻击者 <strong>RCE</strong> 的潜在片段，例如包含
<strong>JNDI</strong> 功能的 <strong>Fragment VI</strong>。</p>
<p>由于 <strong>Fragment V</strong>
具有反射功能，并且参数由攻击者控制，因此 <strong>JDD</strong>
将进一步将其连接。</p>
<h3 id="stage-ii">Stage II</h3>
<p>在步骤 <strong>4</strong> 中，<strong>JDD</strong> 提取
<strong>gadget</strong> 链链接的约束，其中包括如下：</p>
<ol type="1">
<li>结构化约束（即对象和 Field 实例之间的类层次关系）。</li>
<li>Field 依赖约束（对于示例，<strong>n1.key</strong> 和
<strong>n2.key</strong> 的 <strong>hashCode</strong> 应该相同）。</li>
<li>条件分支。</li>
</ol>
<p>需要注意的是，<strong>JDD</strong>
将不同执行路径共享的约束标记为支配者（<strong>dominator</strong>），这意味着它们被所有执行路径所需。</p>
<p>在提取这些约束后，<strong>JDD</strong> 使用一种称为 <strong>Injection
Object Construction Diagram</strong> 的新数据结构来模拟对象 Field
之间的数据流依赖关系，并指导动态模糊测试。</p>
<p>最后，在步骤 <strong>5</strong> 中，<strong>JDD</strong>
仪器化目标程序的收集约束，并使用覆盖支配者约束的数量来指导模糊测试，以生成一个可以利用该
<strong>gadget</strong> 链的注入对象。</p>
<p>具体来说，<strong>JDD</strong> 首先根据 <strong>Injection Object
Construction Diagram</strong>
图中的类层次结构初始化一个实例对象。然后，为对象中的每个 Field
分配适当的值，<strong>JDD</strong>
使用约束求解器解决支配者约束。最后，<strong>JDD</strong>
使用此对象作为种子来驱动定向模糊测试，并利用覆盖的支配约束数量来评估其效能。</p>
<h2 id="步骤-1识别反序列化入口点">步骤 1：识别反序列化入口点</h2>
<p>入口方法有两类：</p>
<ol type="1">
<li><strong>Java</strong> 语言提供的反序列化方法，例如
<strong>readObjectNoData()、readExternal()</strong> 和
<strong>readObject()</strong>。</li>
<li><strong>Java</strong> 反序列化协议提供的接口，例如
<strong>Hessian</strong> 协议的 <strong>Map.put()</strong>。</li>
</ol>
<p>需要注意的是，由于许多这些入口点被定义为接口，<strong>JDD</strong>
进一步识别和分析它们的覆盖或实现方法作为入口点。</p>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240217202942067.png"
alt="Table 1: Popular Deserialization Protocols" />
<figcaption aria-hidden="true">Table 1: Popular Deserialization
Protocols</figcaption>
</figure>
<h2 id="步骤-2使用静态污染分析识别-gadget-片段">步骤
2：使用静态污染分析识别 gadget 片段</h2>
<p>两个子步骤：</p>
<ol type="1">
<li><strong>gadget</strong> 片段形成。</li>
<li>在片段内的数据流分析。</li>
</ol>
<p>首先，将入口点或先前动态方法调用的实现，直到下一个动态方法调用，将其中的代码视为一个片段。</p>
<p>其次，还执行数据流分析，记录片段中第一个方法的参数传播的污染。</p>
<p>具体来说，本文设计了一个基于片段的摘要，对于每个
<strong>gadget</strong>
片段，记录其第一个方法和最后一个方法参数之间的污染行为，并维护一个可到达的终点的记录。</p>
<p>本文将方法之间的跳转转换为 <strong>gadget</strong>
片段之间的跳转，目的是灵活模拟动态方法调用并减少方法之间搜索的计算复杂性。</p>
<h3 id="gadget-片段定义">Gadget 片段定义</h3>
<p>对于每个片段，其终点通常是一个安全敏感的方法或指向另一个片段的动态方法调用，例如
<strong>Object.equals()</strong> 可以连接到几乎所有实现了
<strong>equals()</strong> 方法。</p>
<p>在反序列化过程中，这种动态方法调用确实导致了程序执行方向的存在多种可能性，它们就像
<strong>jump/goto</strong> 指令一样。</p>
<p>具体来说，<strong>gadget</strong> 片段中的方法具有：</p>
<ol type="1">
<li>头部，这是该片段的入口方法，并存在一些动态方法调用可以跳转到该方法。</li>
<li>终点，这是该片段的退出方法，通常是一个动态方法调用或安全敏感的方法。</li>
<li>其他
<strong>gadget</strong>，这些是非动态方法，在反序列化过程中按顺序执行，以连接头部和终点。</li>
</ol>
<h3 id="gadget-片段的动态方法调用类型">Gadget
片段的动态方法调用类型</h3>
<h4 id="多态调用">多态调用</h4>
<p><strong>JDD</strong>
识别目标程序类的继承层次结构，并识别重写的方法。然后，当父类中的方法被调用时，<strong>JDD</strong>
将其连接到其子类实现的相应重写方法。</p>
<p>例如，考虑一个类 <strong>B</strong> 重写了类 <strong>C</strong>
的方法 <strong>m()</strong>，任何以 <strong>C.m()</strong>
为终点的片段都可以跳转到其他以 <strong>B.m()</strong> 为头的片段。</p>
<h4 id="动态代理">动态代理</h4>
<p><strong>Java</strong> 语言支持以接口、<strong>Object</strong>
和其他泛型为类型的对象实现为动态代理实例.</p>
<p>当实例调用任何方法时，它将被重定向到特定的调用处理程序，即在此代理中实现的
<strong>invoke()</strong> 方法。</p>
<p>这种处理程序通常基于触发方法的属性（例如方法名称）部署方法路由。</p>
<p>因此，对于每个处理程序，<strong>JDD</strong>
执行路径敏感分析以了解其方法路由，以确保触发方法不会连接到错误的执行路径。</p>
<p>在实践中，<strong>JDD</strong> 首先在调用处理程序的所有执行路径中识别
<strong>Gadget</strong> 片段，并根据其执行路径为相应的方法属性要求标记
<strong>Gadget</strong> 片段。</p>
<h4 id="反射">反射</h4>
<p>与其他动态特性不同，<strong>Java</strong>
反射可以根据其参数调用程序中几乎所有的方法。</p>
<p><strong>JDD</strong>
首先检查反射的参数是否受攻击者控制，然后限制其连接包含代码执行能力的片段。</p>
<p>请注意，<strong>JDD</strong> 允许反射将任何 <strong>Gadget</strong>
片段连接到其后续片段，但更倾向于两种类型的 <strong>Gadget</strong>
片段：</p>
<ol type="1">
<li>没有参数的方法，特别是 <strong>getter</strong> 或
<strong>is</strong> 方法，和接口方法的实现。</li>
<li>带有布尔或字符串类型的一个参数的方法。</li>
</ol>
<h2 id="步骤-3使用自下而上的方法链接-fragment-片段以构建-gadget-链">步骤
3：使用自下而上的方法链接 Fragment 片段以构建 Gadget 链</h2>
<p>首先，JDD 获得了 3 个类型的 Fragments。</p>
<ol type="1">
<li>Source Fragments，其头部是一个源，例如 Figure 1 中的 Gadget Fragment
I。</li>
<li>Free-State Fragments，记录了两个动态方法调用之间的方法执行顺序，例如
Figure 1 中的 Gadget Fragment II-IV</li>
<li>Sink Fragments，其结尾是一个结束点，例如 Figure 1 中的 Fragment
V、VI。</li>
</ol>
<p>然后将 Sink 连上 Free-State，最后连上 Source。</p>
<p>但是 JDD 需要考虑不同的动态调用对应的污染条件和调用条件，比如 Sink
Fragments 一般有特定参数可以被攻击者控制。</p>
<p>算法 1 中的细节如下：</p>
<p>首先，JDD 连接了可以过渡到 Sink Fragments 的 Free-State
Fragments。</p>
<p>如算法 1 所示，在每一轮中（第 2-19 行），JDD 遍历了 Free-State
Fragments <span class="math inline">\(frag_fs\)</span>。</p>
<p>基于 <span class="math inline">\(frag_fs\)</span>，JDD 检查其链接到
Sink Fragments 是否满足条件。</p>
<p>如果满足，<span class="math inline">\(frag_fs\)</span>
将作为下一次迭代的 Sink Fragments（第 8-9 行）添加到 new Sink Fragments
中，同时跟踪污点需求以满足连接（如果它们与已记录的污点需求相同，则合并它们）（第
11 行）。</p>
<p>由于每次迭代都可以找出所有可能连接到当前 Sink
Fragments，如果这些片段不是 new Sink Fragments 则终止迭代，即当 new Sink
Fragments 为空时（第 15-16 行）或达到最大搜索尝试次数时。</p>
<p>接下来，遍历 Source
Fragments，并采用相同的方法检测可连接的后继片段，从而获得所有潜在的片段链（第
20-26 行）。</p>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240218143156239.png"
alt="Algorithm 1 Gadget Fragments Linking" />
<figcaption aria-hidden="true">Algorithm 1 Gadget Fragments
Linking</figcaption>
</figure>
<p>最后，假设有 n' 个不同的动态方法调用。</p>
<blockquote>
<p>为什么最大迭代次数的上限是n'。</p>
<p>如果迭代次数超过
n'，最长的片段必然包含两个结尾相同的片段，其动态方法调用相同。</p>
<p>由于攻击者有能力调用具有相同动态方法调用的任何候选项，攻击者可以直接提供后一个调用中的类实现以减少总长度，因此两个相同动态方法调用之间的路径是冗余的。</p>
</blockquote>
<h3 id="时间复杂度">时间复杂度</h3>
<p>根据以下定理 1 和 2，JDD 将静态搜索时间从 <span
class="math inline">\(O(eM^n)\)</span>（即现有技术，如ODDFuzz) 减少到
<span class="math inline">\(O(M^2n^3 + enM)\)</span>。</p>
<h3 id="定理-1">定理 1</h3>
<p>算法 1 的搜索复杂度是 <span class="math inline">\(O(M^2n^3 +
enM)\)</span>，其中 <span class="math inline">\(n\)</span>
是动态方法调用的数量，<span class="math inline">\(M\)</span>
是这些调用的候选项的平均数量，<span class="math inline">\(e\)</span>
是入口点的数量。</p>
<h3 id="定理-2">定理 2</h3>
<p>ODDFuzz 的搜索复杂度是 <span
class="math inline">\(O(eM^n)\)</span>，其中所有符号都遵循定理 1。</p>
<h2 id="步骤-4根据注入对象相关约束建立-iocd">步骤
4：根据注入对象相关约束建立 IOCD</h2>
<p>两个步骤：</p>
<ol type="1">
<li>约束提取</li>
<li>基于注入对象相关约束的 IOCD 生成</li>
</ol>
<p>首先，JDD 遵循这个 gadget
链的调用序列来提取执行路径，然后发现影响输入的三种类型的约束：</p>
<h3 id="object-和-field-实例之间的层次关系">Object 和 Field
实例之间的层次关系</h3>
<p>对于每个 Fragment，JDD 首先使用数据流分析来确定哪些 Fragment 与下一个
Fragment 链接，然后使用后续 Fragment 的头部方法确定 Field
的实际类型。</p>
<blockquote>
<p>比如图 1 中第 3 行，HashMap 对象具有一个 Field table。</p>
</blockquote>
<p>但是有一些定义的是通用类型或者 Object，因此 JDD 会继续向下追踪。</p>
<blockquote>
<p>比如图 1 中，key 将 Fragment I 连接到 II，obj.key 和 this.key 将
Fragment II 连接到 III，Fragment III 将 Fragment IV 连接到 IV。</p>
</blockquote>
<h3 id="与-field-相关的条件分支">与 Field 相关的条件分支</h3>
<p>JDD 标记在不同的执行路径中共享的约束为
dominator，这意味着所有执行路径都需要满足这些约束。</p>
<p>在数据流跟踪过程中，JDD 同时通过识别受 Field 影响的变量来收集与 Field
相关的条件分支约束。</p>
<p>此外，为了确保程序执行不会触发异常，还应满足一些隐式约束。</p>
<blockquote>
<p>例如，在调用某些方法时， Field 不能为
null。另一个例子是强制类型转换，它要求 Field 应是特定类型的实例。</p>
</blockquote>
<h3 id="field-依赖约束">Field 依赖约束</h3>
<p>其中包括 Field 之间的条件约束，如图 3 中所示的约束 i-iii。</p>
<p>需要注意的是，sink 点通常要求特定 Field 由攻击者控制以注入
payload。</p>
<p>JDD 将标记这些 Field 以检查它们是否可以被输入污染。</p>
<p>为了找到 Field 依赖性约束，通常情况下，JDD 会过滤影响多个 Field
的条件约束，然后将这些 Field 标记为相关约束的 Field 依赖。</p>
<p>此外，JDD 还考虑了 Java 反射的特定要求。</p>
<blockquote>
<p>例如，在 Java 反射中使用的三个 Field className、methodName 和 args
应确保目标类包含目标方法。</p>
</blockquote>
<h3 id="注入对象构造图">注入对象构造图</h3>
<p>在提取这些约束之后，JDD
使用一种新的数据结构，称为注入对象构造图（IOCD）来建模对象结构和 Field
的依赖关系。</p>
<p>有两个子步骤：</p>
<ol type="1">
<li><p>JDD 将包含在 gadget 链中的实例化对象视为
ClassNodes。每个ClassNode 存储以下信息：类名和相关的
FieldNodes，表示在反序列化过程中可能使用的 Field 。另一方面，FieldNode
存储这些 Field 的相关约束信息，并标记这些约束是否可以静态确定为
dominator。</p></li>
<li><p>根据结构约束，通过 FieldNodes 将 ClassNodes
相互连接，从而指示实例化对象之间的层次关系。</p>
<blockquote>
<p>例如，在示例中，JDD 将构造 ClassNodes 表示 NodeImpl、UIDfaults 和
ConcurrentHashMap 的实例。然后，根据结构约束，JDD 将从 UIDfaults 和
ConcurrentHashMap ClassNodes 建立到 NodeImpl ClassNode 的相同
FieldNode（即 key）的边，这意味着至少存在两个 NodeImpl 实例。因此，JDD
将包含一个额外的 NodeImpl ClassNode 来表示两个 NodeImpl
实例的存在，其中每个实例的 Field key 分别分配给 UIDfaults 和
ConcurrentHashMap 实例，如图 3（a）所示。</p>
</blockquote></li>
</ol>
<h2 id="步骤-5iocd-增强方向性模糊测试">步骤 5：IOCD
增强方向性模糊测试</h2>
<p>具体来说，首先基于 <strong>IOCD</strong>
生成初始种子，然后使用它们来驱动模糊测试。</p>
<p>在方向性模糊测试的探索阶段，<strong>JDD</strong> 利用覆盖的
<strong>dominator</strong> 约束的数量来评估种子的能效，并引导
<strong>fuzzer</strong> 覆盖更多的 <strong>dominator</strong>
约束，直到达到 <strong>sink</strong> 点。</p>
<p>在方向性模糊测试的利用阶段，JDD 仅变动与 sink 点相关的 Field。在每个
Field 的变动过程中，根据 IOCD 调整其他相关 Field，以修复基于 IOCD 的跨
Field 依赖关系。</p>
<h3 id="基于-iocd-的种子生成">基于 IOCD 的种子生成</h3>
<p>考虑到 Cross-Field 依赖和嵌套对象结构，JDD 使用基于 IOCD 引导的
fuzzer ，并考虑 Field 之间的约束来生成正确类层次结构的对象。</p>
<p>具体来说，基于 IOCD 从 ClassNodes
生成无参数实例，并根据有向边建立这些实例的类层次结构，如图 3 所示。</p>
<p>随后，从根 ClassNode 节点开始，在每个 FieldNode
上执行广度优先遍历。</p>
<p>JDD 将提取这些 FieldNodes 的 dominator
约束，并调用约束求解器生成适当的值，然后将这些值分配给相应的 Field
。</p>
<p>当双向边存在 FieldNodes 之间的时候，表示两个 Field
之间存在约束依赖关系，JDD 会从相关 FieldNodes 提取 dominator
条件约束。</p>
<p>然后，使用约束求解器解决这些约束，以找到同时满足这些约束的值。</p>
<h3 id="依赖感知种子变动">依赖感知种子变动</h3>
<p>IOCD 从以下三个方面显著提高了模糊测试的效率：</p>
<ol type="1">
<li>选择适当的 Field 进行变动。</li>
<li>通过约束信息减少不确定的变动空间。</li>
<li>考虑 Field 之间的依赖关系和嵌套对象结构。</li>
</ol>
<p>在变动 Field 时，需要考虑到该 Field 与其他相关 Field 或包含该 Field
的上级实例对象之间的约束关系。详细策略可在表 2 中找到。</p>
<figure>
<img
src="/images/Paper-Efficient-Detection-of-Java-Deserialization-Gadget-Chains-via-Bottom-up-Gadget-Search-and-Dataflow-aided-Payload-Construction/image-20240218223439227.png"
alt="Table 2: Mutation Strategy." />
<figcaption aria-hidden="true">Table 2: Mutation Strategy.</figcaption>
</figure>
<h4 id="基于条件约束的变动">基于条件约束的变动</h4>
<p>首先，根据种子执行获取的反馈信息，JDD 匹配来自 IOCD
的适当条件约束，这些约束是从指定程序执行流程中导出的 gadget 链。</p>
<p>然后利用这些条件约束来有选择性地指导注入对象的结构变动。</p>
<p>为了记录所选的条件约束策略，JDD 定义了一个唯一标识符，并分配一个 2
位标志来指示每个条件约束的变动策略。</p>
<p>第一位用于指示约束是否被使用（0：未选中，1：选中），第二位表示约束是否满足（true
or false）。</p>
<p>有了这个标识符，JDD
更倾向于选择未使用的策略，以涵盖更多种类的条件约束组合。</p>
<p>以下是如何基于反馈信息生成条件约束分支策略的解释：</p>
<ol type="1">
<li>如果 JDD 解决了 ClassCastException 或 NullPointerException
异常信息，则可以根据错误位置信息（类名、代码行号）从 IOCD
中匹配引起异常的相关 Field ，并要求这些 Field 满足特定的约束，即 <span
class="math inline">\(field \; != \; null，field \; instanceof \;
X.class\)</span>。</li>
<li>提取当前达到的条件约束和下一个 dominator
条件约束之间的所有约束，并根据每个约束的标识符选择变动策略。</li>
<li>如果当前和下一个 dominator 条件约束之间没有非 dominator
条件约束，则为当前 dominator 和前面的条件约束选择随机变动策略，注意
dominator 条件约束不改变第二位标志。</li>
<li>如果程序已达到汇合点但未触发预期的恶意指令，则 JDD
首先检查是否存在多种构造恶意数据的方法（即从不同 Field
构造）。如果存在这样的变化，JDD 使用 IOCD 中记录的信息调用不同的 Field
来构造恶意数据。否则，随机更改条件约束策略。</li>
<li>如果已使用所有条件约束策略的组合，则为从未标记为现有条件约束的 IOCD
中随机选择的 Field 分配 50％ 的概率进行变动。</li>
<li>当程序到达汇合点并捕获到写入的恶意指令时，这意味着注入对象是可利用的，并且相应的片段链被归类为可利用。如果超过了时间阈值，或者根据上述特定类型的信息，可以直接确定为不可利用，当前测试将终止，并且将调用下一个
IOCD 来对应下一个片段链，以开始新一轮的测试。</li>
</ol>
<h4 id="基于对象结构约束的变动">基于对象结构约束的变动</h4>
<p>在获得条件约束之后，JDD 调用约束求解器来调整对象的结构。</p>
<p>然而，正如 IOCD 所示， Field 之间存在复杂的约束关系。</p>
<p>修改其中一个 Field 不仅会影响相应的 ClassNode，还会影响其 Field
以及与其他 ClassNode 关联的 Field 。</p>
<p>因此，仅基于条件约束对单个 Field
进行简单调整可能会损害对象的结构有效性。</p>
<p>为了解决这个问题，本文提出了级联变动策略。</p>
<p>当 JDD 调整一个 Field 时，它会级联地检查受此 Field 影响的其他 Field
是否也需要调整。</p>
<p>如果需要，它会同时调整它们，以保持注入对象的结构有效性。</p>
<p>具体来说，变动策略可以分为两个级别：单 Field 和跨 Field 。</p>
<ol type="1">
<li>单 Field 级别。变动单个 Field ，该 Field 与其他 Field
没有任何约束。利用约束求解器来解决相关的条件约束，以调整 Field
的赋值。</li>
<li>跨 Field 级别。当变动一个具有其他 Field 之间相互约束的 Field
时，确保保留相关 Field 中的相关信息，并保持对象结构的有效性。</li>
</ol>
<h4 id="基于-field-依赖约束的变动">基于 Field 依赖约束的变动</h4>
<p>基于对受影响 Field
进行最小修改以避免在变动后破坏有效信息的见解，并利用类层次结构的知识，JDD
实现了以下两种跨 Field 级别的变动器，即嵌套 Field
值重用和顺序固定调整。</p>
<h5 id="嵌套-field-值重用">嵌套 Field 值重用</h5>
<p>在变动特定 Field （即 mutatedField）后，递归检查和调整其相关 Field
。</p>
<p>具体来说，首先根据 IOCD 上的相关支配约束调整 mutatedField 的 Field
。</p>
<p>然后，检测当前约束策略影响的 Field ，并重用变动后和变动前 Field
实例之间共享的实例。</p>
<h5 id="顺序固定调整">顺序固定调整</h5>
<p>如果 JDD 打算变动特定 Field （即 field1），并且存在与多个 Field
相关的约束（即 field2、field3），JDD 分别提取与这三个 Field
相关的约束。</p>
<p>然后调用约束求解器为 field1 找到满足所有相关约束的值，同时尽量减少
field2 和 field3 的调整。</p>
<p>具体来说，约束求解器首先固定 field2 和 field3，然后确定 field1
的适当值。</p>
<p>如果它无法找到满足 field1 的其他约束的解决方案，则逐步调整 field2 和
field3 并继续解决过程。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Paper/" rel="tag"><i class="fa fa-tag"></i> Paper</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Paper-Scalable-Edge-Blocking-Algorithms-for-Defending-Active-Directory-Style-Attack-Graphs/" rel="prev" title="论文 Scalable Edge Blocking Algorithms for Defending Active Directory Style Attack Graphs">
                  <i class="fa fa-chevron-left"></i> 论文 Scalable Edge Blocking Algorithms for Defending Active Directory Style Attack Graphs
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Paper-Code-Generation-with-AlphaCodium/" rel="next" title="论文 Code Generation with AlphaCodium： From Prompt Engineering to Flow Engineering">
                  论文 Code Generation with AlphaCodium： From Prompt Engineering to Flow Engineering <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments disqusjs-container">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南溟NaN</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/disqusjs/3.0.2/styles/disqusjs.css" integrity="sha256-71XarXwNr1Td27HmZI9zjY+rMzRdush6/glo6VFXp7o=" crossorigin="anonymous">

<script class="next-config" data-name="disqusjs" type="application/json">{"enable":true,"api":"https://disqus.skk.moe/disqus/","apikey":"Cz7uQCDoGwWYGv80HeDq40mZr1rrmYy9tHhCpcWG95DFzOD1TJKLXtbTxFqWBCr5","shortname":"southseast","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/disqusjs/3.0.2/disqusjs.es2015.umd.min.js","integrity":"sha256-okP99ZQKVpIy7+NogAMpGlIQzJa9XKXhIJcFgdju5bU="}}</script>
<script src="/js/third-party/comments/disqusjs.js"></script>

</body>
</html>
